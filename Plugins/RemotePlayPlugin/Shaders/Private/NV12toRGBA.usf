// (c) 2018 Simul.co

#include "/Engine/Public/Platform.ush"

Buffer<uint> InputBuffer;
RWTexture2D<float4> RWOutputTexture;

static const uint Pitch = 1024;

static const float3x3 YUVtoRGB_ITU709 =
{ 
	1.0,  0.0,       1.5748,
	1.0, -0.187324, -0.468124,
	1.0,  1.8556,    0.0
};

float3 YUVtoRGB(float3 YUV)
{
	YUV.gb -= 0.5;
	return mul(YUVtoRGB_ITU709, YUV);
}

float4 GatherY(uint2 P)
{
	uint4 Loc = uint4(
		P.y     * Pitch + P.x,
		P.y     * Pitch + P.x + 1,
		(P.y+1) * Pitch + P.x,
		(P.y+1) * Pitch + P.x + 1);
	return float4(InputBuffer.Load(Loc.x), InputBuffer.Load(Loc.y), InputBuffer.Load(Loc.z), InputBuffer.Load(Loc.w)) / 255.0;
}

float2 GatherUV(uint Size, uint2 P)
{
	uint2 Loc = Size + uint2(
		P.y/2 * Pitch + P.x, 
		P.y/2 * Pitch + P.x + 1);
	return float2(InputBuffer.Load(Loc.x), InputBuffer.Load(Loc.y)) / 255.0;
}

[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void MainCS(uint2 ThreadID : SV_DispatchThreadID)
{
	uint OutputW, OutputH;
	RWOutputTexture.GetDimensions(OutputW, OutputH);

	uint2  P  = 2 * ThreadID;
	float4 Y  = GatherY(P);
	float2 UV = GatherUV(Pitch * OutputH, P);

	RWOutputTexture[int2(P.x  , P.y  )] = float4(YUVtoRGB(float3(Y.x, UV.x, UV.y)), 1.0);
	RWOutputTexture[int2(P.x+1, P.y  )] = float4(YUVtoRGB(float3(Y.y, UV.x, UV.y)), 1.0);
	RWOutputTexture[int2(P.x  , P.y+1)] = float4(YUVtoRGB(float3(Y.z, UV.x, UV.y)), 1.0);
	RWOutputTexture[int2(P.x+1, P.y+1)] = float4(YUVtoRGB(float3(Y.w, UV.x, UV.y)), 1.0);
}
